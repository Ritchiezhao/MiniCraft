/********************************************************************
	created:	20:12:2012   0:39
	filename: 	F:\MiniCraft\Editor\SceneEdit\Manipulator\ManipulatorObject.h
	author:		maval
	
	purpose:	可摆放物体创建,管理,操控.
*********************************************************************/

#ifndef ManipulatorObject_h__
#define ManipulatorObject_h__

#include "ManipulatorEventCallback.h"
#include "EditorDefine.h"

class GizmoAxis;

///物体信息封装结构
struct SObjectInfo 
{
	SObjectInfo():	m_bAddToNavmesh(false),m_bIsBuilding(false),m_bIsResource(false) {}
	bool			m_bAddToNavmesh;	//是否参与NavMesh构建
	bool			m_bIsBuilding;		//是否是游戏建筑
	std::string		m_buildingName;		//若是建筑,建筑名称
	bool			m_bIsResource;		//是否是游戏资源
};

typedef std::unordered_map<Ogre::Entity*, SObjectInfo*> ObjectContainer;

class ManipulatorObject : public ManipulatorSceneEventCallback, public ManipulatorCallbackManager<ManipulatorObjectEventCallback>
{
public:
	enum eEditMode
	{
		eEditMode_None,
		eEditMode_Move,
		eEditMode_Rotate,
		eEditMode_Scale,
		eEditMode_Select
	};

	//////////////事件回调
	virtual void	OnSceneClose();
	virtual void	OnSceneNew();
	virtual void	OnSceneOpen();

public:
	ManipulatorObject();
	~ManipulatorObject();

public:
	void		Load(rapidxml::xml_node<>* XMLNode);
	void		OnFrameMove(float dt);
	eEditMode	GetCurEditMode() const { return m_curEditMode; }
	void		SetCurEditMode(eEditMode mode) { m_curEditMode = mode; }
	const ObjectContainer&	GetAllObjects() const { return m_objects; }

	//创建Entity
	Ogre::Entity* AddEntity(const Ogre::String& meshname, const Ogre::Vector3& worldPos, 
		const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& scale = Ogre::Vector3(1,1,1));
	Ogre::Entity* AddEntity(const Ogre::String& meshname, const Ogre::Vector2& screenPos);

	///物体选择
	void		SetSelection(Ogre::Entity* pEnt);
	Ogre::Entity*	GetSelection() const { return m_pSelectEntity; }
	void		ClearSelection();
	void		SelectionSetPosition(const Ogre::Vector3& newPos);
	void		SelectionSetOrientation(const Ogre::Quaternion& orient);
	void		SelectionSetScale(const Ogre::Vector3 scale);
	void		SelectionRotate(float radian);
	void		SelectionScale(const Ogre::Vector3& scaleMultiplier);

	//取得Entity的包围盒Gizmo.包围盒显示由我们自己管理,不使用OGRE默认的showBoundingBox
	Ogre::WireBoundingBox*	GetEntityAABBGizmo(Ogre::Entity* pEntity);
	//根据操作模式,显示物体相应的Gizmo
	void		ShowEntityGizmo(Ogre::Entity* pEntity, bool bShow, eEditMode mode, bool bDrift = false);
	GizmoAxis*	GetGizmoAxis() const { return m_pGizmoAixs; }
	void		OnGizmoNodeReset();
	void		SetObjectNavMeshFlag(Ogre::Entity* pEntity, bool bIsNavMesh);
	bool		GetObjectNavMeshFlag(Ogre::Entity* pEntity) const;
	void		SetObjectIsBuilding(Ogre::Entity* pEntity, bool bIsBuilding);
	bool		GetObjectIsBuilding(Ogre::Entity* pEntity) const;
	void		SetObjectBuildingName(Ogre::Entity* pEntity, const std::string& name);
	const std::string&		GetObjectBuildingName(Ogre::Entity* pEntity) const;
	void		SetObjectIsResource(Ogre::Entity* pEntity, bool bIsResource);
	bool		GetObjectIsResource(Ogre::Entity* pEntity) const;

	//射线查询
	Ogre::MovableObject* DoRaySceneQuery(const Ogre::Ray& ray, int queryMask = 0xffffffff);
	void		DoAABBSceneQuery(const Ogre::AxisAlignedBox& aabb, int queryMask = 0xffffffff);

	//Animation
	std::vector<std::wstring> GetAnimationNames(Ogre::Entity* pEntity) const;
	void		PlayAnimation(Ogre::Entity* pEntity, int animIndex);

private:
	void		_UpdateAABBOfEntity(Ogre::Entity* pEntity);

private:
	ObjectContainer	m_objects;			//场景中的所有摆放物体
	eEditMode		m_curEditMode;
	Ogre::Entity*	m_pSelectEntity;	//当前选中物体
	GizmoAxis*		m_pGizmoAixs;		//坐标轴指示器
	Ogre::RaySceneQuery* m_pRaySceneQuery;
	Ogre::AxisAlignedBoxSceneQuery*	m_pAABBSceneQuery;
	Ogre::Entity*	m_pAnimEntity;		//当前播放动画物体
	Ogre::AnimationState*	m_pAnimState;
};


#endif // ManipulatorObject_h__







